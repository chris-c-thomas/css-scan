import { chromium } from 'playwright';
import fs from 'node:fs/promises';
import path from 'node:path';
import * as prettier from 'prettier';
import { CssUsageResult } from '../types.js';

const VIEWPORTS = [
    { width: 1920, height: 1080, label: 'Desktop (1920x1080)' },
    { width: 768, height: 1024, label: 'Tablet (768x1024)' },
    { width: 375, height: 667, label: 'Mobile (375x667)' },
];

export async function scanCssCoverage(url: string): Promise<CssUsageResult> {
    const browser = await chromium.launch({
        headless: true,
    });

    try {
        const page = await browser.newPage();

        // 1. Start CSS Coverage
        await page.coverage.startCSSCoverage({ resetOnNavigation: false });

        // 2. Cycle through Viewports
        for (const viewport of VIEWPORTS) {
            await page.setViewportSize(viewport);

            if (viewport === VIEWPORTS[0]) {
                await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
            }

            await page.waitForTimeout(500);

            await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
            await page.waitForTimeout(200);
            await page.evaluate(() => window.scrollTo(0, 0));
        }

        // 3. Stop Coverage
        const coverage = await page.coverage.stopCSSCoverage();

        // 4. Calculate Usage & Extract CSS
        let totalBytes = 0;
        let usedBytes = 0;
        let finalCss = '/* Generated by CSS-Scan CLI */\n';

        for (const entry of coverage) {
            const entryLength = entry.text ? entry.text.length : 0;
            totalBytes += entryLength;

            if (entry.text) {
                for (const range of entry.ranges) {
                    usedBytes += range.end - range.start;
                    const chunk = entry.text.slice(range.start, range.end);
                    finalCss += chunk + '\n';
                }
            }
        }

        // --- FIX: Heuristic Brace Balancing ---
        // Count braces to ensure we didn't slice off a closing '}' for a media query
        let openBraces = 0;
        for (const char of finalCss) {
            if (char === '{') openBraces++;
            if (char === '}') openBraces--;
        }

        // If we have more opens than closes, append the missing closes
        while (openBraces > 0) {
            finalCss += '}\n';
            openBraces--;
        }

        // 5. Format and Write to file
        const outputFilename = 'used.css';
        const outputPath = path.resolve(process.cwd(), outputFilename);

        try {
            // Try to make it pretty
            const formattedCss = await prettier.format(finalCss, { parser: 'css' });
            await fs.writeFile(outputPath, formattedCss, 'utf-8');
        } catch (formatError) {
            // Fallback: If Prettier fails (e.g. weird syntax), save raw file
            // This prevents the CLI from crashing completely
            console.warn('Warning: CSS formatting failed. Saving raw output.');
            await fs.writeFile(outputPath, finalCss, 'utf-8');
        }

        const unusedBytes = totalBytes - usedBytes;
        const unusedPercentage = totalBytes > 0
            ? ((unusedBytes / totalBytes) * 100).toFixed(2)
            : '0';

        return {
            url,
            totalBytes,
            usedBytes,
            unusedBytes,
            unusedPercentage,
            scannedViewports: VIEWPORTS.map(v => v.label),
            outputFile: outputFilename
        };

    } catch (error) {
        throw error;
    } finally {
        await browser.close();
    }
}