import { chromium } from 'playwright';
import fs from 'node:fs/promises';
import path from 'node:path';
import * as prettier from 'prettier';
import { CssUsageResult } from '../types.js';

const VIEWPORTS = [
    { width: 1920, height: 1080, label: 'Desktop (1920x1080)' },
    { width: 768, height: 1024, label: 'Tablet (768x1024)' },
    { width: 375, height: 667, label: 'Mobile (375x667)' },
];

/**
 * A basic regex-based formatter for when Prettier gives up.
 * Ensures the output is at least readable (newlines, indentation)
 * even if the CSS syntax is technically invalid.
 */
function formatFallback(css: string): string {
    return css
        .replace(/\s*([{}])\s*/g, ' $1\n')     // Add space before, newline after braces
        .replace(/;\s*/g, ';\n  ')             // Newline + indent after semicolons
        .replace(/\s*{\s*/g, ' {\n  ')         // Clean up open braces
        .replace(/\n\s*}\s*/g, '\n}\n')        // Clean up close braces
        .replace(/,\s*/g, ', ')                // Space after commas
        .replace(/\n\s*\n/g, '\n');            // Remove double newlines
}

/**
 * Helper to safely format and write CSS files.
 * Handles brace balancing and Prettier fallbacks.
 */
async function writeCssFile(filename: string, content: string, header: string = ''): Promise<string> {
    // 1. Brace Balancing (Heuristic)
    let openBraces = 0;
    for (const char of content) {
        if (char === '{') openBraces++;
        if (char === '}') openBraces--;
    }

    // If we have more opens than closes, append the missing closes
    let balancedContent = content;
    while (openBraces > 0) {
        balancedContent += '}\n';
        openBraces--;
    }

    // Handle negative braces (more closes than opens)
    while (openBraces < 0) {
        balancedContent = '{\n' + balancedContent;
        openBraces++;
    }

    // Prepend header AFTER balancing to ensure it is at the very top
    if (header) {
        balancedContent = header + balancedContent;
    }

    const outputPath = path.resolve(process.cwd(), filename);

    try {
        // 2. Try to format with Prettier (The Gold Standard)
        const formattedCss = await prettier.format(balancedContent, { parser: 'css' });
        await fs.writeFile(outputPath, formattedCss, 'utf-8');
    } catch (formatError) {
        // 3. Fallback: Use Regex formatting if Prettier fails
        // This catches the syntax errors common in "unused" CSS fragments
        const readableCss = formatFallback(balancedContent);
        await fs.writeFile(outputPath, readableCss, 'utf-8');
    }

    return filename;
}

export async function scanCssCoverage(url: string): Promise<CssUsageResult> {
    const browser = await chromium.launch({
        headless: true,
    });

    try {
        const page = await browser.newPage();

        // 1. Start CSS Coverage
        await page.coverage.startCSSCoverage({ resetOnNavigation: false });

        // 2. Cycle through Viewports
        for (const viewport of VIEWPORTS) {
            await page.setViewportSize(viewport);

            if (viewport === VIEWPORTS[0]) {
                await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
            }

            await page.waitForTimeout(500);

            await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
            await page.waitForTimeout(200);
            await page.evaluate(() => window.scrollTo(0, 0));
        }

        // 3. Stop Coverage
        const coverage = await page.coverage.stopCSSCoverage();

        // 4. Calculate Usage & Extract Strings
        let totalBytes = 0;
        let usedBytes = 0;

        let usedCssBuffer = '';
        let unusedCssBuffer = '';

        for (const entry of coverage) {
            if (!entry.text) continue;

            const entryLength = entry.text.length;
            totalBytes += entryLength;

            let cursor = 0;

            for (const range of entry.ranges) {
                usedBytes += range.end - range.start;

                // A. Capture UNUSED (The gap between cursor and current range start)
                if (range.start > cursor) {
                    unusedCssBuffer += entry.text.slice(cursor, range.start) + '\n';
                }

                // B. Capture USED (The current range)
                usedCssBuffer += entry.text.slice(range.start, range.end) + '\n';

                cursor = range.end;
            }

            // C. Capture Trailing UNUSED
            if (cursor < entryLength) {
                unusedCssBuffer += entry.text.slice(cursor, entryLength) + '\n';
            }
        }

        // 5. Write Files
        const outputFile = await writeCssFile('used.css', usedCssBuffer, '/* used.css generated by css-scan */\n');
        const unusedOutputFile = await writeCssFile('unused.css', unusedCssBuffer, '/* unused.css generated by css-scan */\n');

        const unusedBytes = totalBytes - usedBytes;
        const unusedPercentage = totalBytes > 0
            ? ((unusedBytes / totalBytes) * 100).toFixed(2)
            : '0';

        return {
            url,
            totalBytes,
            usedBytes,
            unusedBytes,
            unusedPercentage,
            scannedViewports: VIEWPORTS.map(v => v.label),
            outputFile,
            unusedOutputFile
        };

    } catch (error) {
        throw error;
    } finally {
        await browser.close();
    }
}